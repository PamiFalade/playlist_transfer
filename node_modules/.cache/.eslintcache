[{"/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/index.js":"1","/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/App.js":"2","/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/reportWebVitals.js":"3","/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/Landing.js":"4","/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/models/webService.js":"5"},{"size":582,"mtime":1650643809183,"results":"6","hashOfConfig":"7"},{"size":192,"mtime":1650870660076,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":1650391817756,"results":"9","hashOfConfig":"7"},{"size":8476,"mtime":1651084214606,"results":"10","hashOfConfig":"7"},{"size":4311,"mtime":1650868079929,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},"addlp4",{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"30"},"/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/index.js",[],[],[],"/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/App.js",[],[],"/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/reportWebVitals.js",[],[],"/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/Landing.js",["31","32","33","34","35","36","37","38","39","40","41","42"],[],"import { React, useState } from \"react\";\nimport \"./Views/LandingViews.css\";\nimport Card from \"react-bootstrap/Card\";\nimport Modal from \"react-bootstrap/Modal\";\nimport Button from \"react-bootstrap/Button\";\nimport Form from \"react-bootstrap/Form\";\nimport { useFormik } from \"formik\";\nimport { Buffer } from \"buffer\";\nimport { fetchPlaylist, setupToken } from \"./models/webService\";\n\n//TO-DO: Finish up styling of track display, and figure out how to surpass the 100 song limit\n\nconst Landing = () => {\n  //show variable for displaying the modal that takes the playlist link and call the handleTransfer function\n  const [showLinkModal, setShowLinkModal] = useState(false);\n  const handleShowLinkModal = () => setShowLinkModal(true);\n  const handleCloseLinkModal = () => setShowLinkModal(false);\n\n  //show variable for displaying the modal that displays the playlist that was fetched from the source platform\n  const [showConfirmModal, setShowConfirmModal] = useState(false);\n  const handleShowConfirmModal = () => setShowConfirmModal(true);\n  const handleCloseConfirmModal = () => setShowConfirmModal(false);\n\n  //source and dest variables to represent the origin platform and destination platform of the playlist respectively\n  const [source, setSource] = useState(\"\");\n  const [dest, setDest] = useState(\"\");\n  //sets source and dest variables\n  const handleTransfer = (source, dest) => {\n    setSource(source);\n    setDest(dest);\n  };\n\n  //variable to hold the access token\n  const [sourceToken, setSourceToken] = useState(\"\");\n\n  //Link that has been entered into\n  const playlistLink = \"\";\n  //Object that will hold relevant info on the playlist to be transferred\n  const [playlist, setPlaylist] = useState({});\n\n  //Formik to manage and validate inputted link\n  const initialValues = {\n    link: \"\",\n  };\n\n  const onSubmit = (values) => {\n    //Step 1: get access token for source platform\n    setupToken(source).then((promise) => {\n      //By making setupToken an async function, you made it so that it returns a promise. So, it needs to be treated as such\n      setSourceToken(promise.token); //Use this function to notify when source token has been updated\n\n      //Step 2: retrieve playlist from source platform\n      fetchPlaylist(values.link, promise.token, source)\n        .then((retrievedPlaylist) => {\n          let foundPlaylist = {\n            //I initially tried just having a global playlist object variable and updating it with these values\n            name: retrievedPlaylist.name, //But its attributes didn't seem to be updating in time before the modal would be rendered\n            image: retrievedPlaylist.images[1].url, //The useState function triggers a re-render of the DOM, so that's what you should use so that the DOM re-renders when those variables have been updated\n            owner: retrievedPlaylist.owner.display_name, //Lesson learned: that's why you should use the state for data that needs to be kept track of and needs to be rendered (it's just better and easier to manage)\n            tracks: retrievedPlaylist.tracks.items.map((song) => {\n              return {\n                songName: song.track.name,\n                isExplicit: song.track.explicit,\n                songAlbum: song.track.album.name,\n                songAlbumImg: song.track.album.images[2],\n                songArtists: [...song.track.artists],\n                sourceURI: song.track.uri,\n                destURI: \"\",\n              };\n            }),\n          };\n          setPlaylist(foundPlaylist);\n        })\n        .then(() => {\n          handleShowConfirmModal();\n        })\n        .catch((error) => console.log(error));\n    });\n\n    //Step 2: retrieve playlist from source platform\n  };\n\n  const validate = (values) => {\n    let errors = {};\n\n    if (!values.link) {\n    }\n  };\n\n  const linkForm = useFormik({ initialValues, onSubmit, validate });\n\n  return (\n    <div>\n      <Card className=\"Landing\" border=\"primary\">\n        <Card.Header>\n          <Card.Title>Welcome!</Card.Title>\n        </Card.Header>\n        <Card.Body className=\"LandingBody\">\n          <Card\n            border=\"primary\"\n            className=\"transferOption\"\n            onClick={() => {\n              handleShowLinkModal();\n              handleTransfer(\"apple\", \"spotify\");\n            }}\n          >\n            <Card.Body>\n              <img\n                src=\"https://pbs.twimg.com/profile_images/1431129444362579971/jGrgSKDD_400x400.jpg\"\n                className=\"Logo\"\n              />\n              <img\n                src=\"https://toppng.com/uploads/preview/right-arrow-icon-ico-11562931718i8rqgsef9d.png\"\n                className=\"Logo\"\n              />\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Spotify_logo_without_text.svg/800px-Spotify_logo_without_text.svg.png\"\n                className=\"Logo\"\n              />\n            </Card.Body>\n          </Card>\n          <Card\n            border=\"primary\"\n            className=\"transferOption\"\n            onClick={() => {\n              handleShowLinkModal();\n              handleTransfer(\"spotify\", \"apple\");\n            }}\n          >\n            <Card.Body>\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Spotify_logo_without_text.svg/800px-Spotify_logo_without_text.svg.png\"\n                className=\"Logo\"\n              />\n              <img\n                src=\"https://toppng.com/uploads/preview/right-arrow-icon-ico-11562931718i8rqgsef9d.png\"\n                className=\"Logo\"\n              />\n              <img\n                src=\"https://pbs.twimg.com/profile_images/1431129444362579971/jGrgSKDD_400x400.jpg\"\n                className=\"Logo\"\n              />\n            </Card.Body>\n          </Card>\n        </Card.Body>\n      </Card>\n\n      <Modal show={showLinkModal} onHide={handleCloseLinkModal}>\n        <Modal.Header closeButton>\n          <Modal.Title>Let's transfer!</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          <Form\n            onSubmit={() => {\n              handleCloseLinkModal();\n              linkForm.handleSubmit();\n            }}\n          >\n            <Form.Label>Share Link for Playlist</Form.Label>\n            <Form.Control\n              name=\"link\"\n              id=\"link\"\n              type=\"url\"\n              placeholder=\"Enter the link to the playlist\"\n              onChange={linkForm.handleChange}\n              value={linkForm.values.link}\n            />\n          </Form>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"secondary\" onClick={handleCloseLinkModal}>\n            Close\n          </Button>\n          <Button\n            variant=\"primary\"\n            onClick={() => {\n              handleCloseLinkModal();\n              linkForm.handleSubmit();\n            }}\n            type=\"submit\"\n          >\n            Submit\n          </Button>\n        </Modal.Footer>\n      </Modal>\n\n      <Modal\n        show={showConfirmModal}\n        onHide={handleCloseConfirmModal}\n        backdrop=\"static\"\n        contentClassName=\"PlaylistDisplayModal\"\n      >\n        <Modal.Header>\n          <Modal.Title>This Playlist?</Modal.Title>\n        </Modal.Header>\n\n        <Modal.Body className=\"PlaylistDisplayModalBody\">\n          <div className=\"leftSide\">\n            <img\n              src={playlist.image}\n              alt=\"Playlist Cover\"\n              width=\"100%\"\n              height=\"100%\"\n            />\n            <h1>{playlist.name}</h1>\n          </div>\n          <div className=\"rightSide\">\n            <div className=\"trackList\">\n              {/* Kept getting: \"Uncaught TypeError: Cannot read properties of undefined (reading 'map')\" without the question mark\n                    The question mark checks that the array exists first before executing the map function*/}\n              {playlist.tracks?.map((song, index) => (\n                <div className=\"trackDisplay\" key={index}>\n                  <img src={song.songAlbumImg.url} />\n                  <p>{song.songName}</p>\n                </div>\n              ))}\n            </div>\n          </div>\n        </Modal.Body>\n\n        <Modal.Footer>\n          <Button variant=\"secondary\" onClick={handleCloseConfirmModal}>\n            Nope\n          </Button>\n          <Button variant=\"primary\" onClick={handleCloseConfirmModal}>\n            Yes!\n          </Button>\n        </Modal.Footer>\n      </Modal>\n    </div>\n  );\n};\n\nexport default Landing;\n","/Users/pamilerinfalade/Desktop/FrontEnd_Challenges/playlist-transfer/src/models/webService.js",["43"],[],"import { Buffer } from \"buffer\";\n\n//Object used to store the clientIDs and secrets of the various platforms\nconst credentials = {\n  spotify_clientID: \"9a5c9f439d464286b0b08e0f40de4f4a\",\n  spotify_secret: \"c24f98c34e26485db177b530895c1769\",\n  apple_clientID: \"\",\n  apple_secret: \"\",\n  apple_playlistID_regex: \"\",\n};\n\n//Object used to store the regex patterns needed to extract info from url's\nconst regexes = {\n  spotify_playlistID_regex: \"(?<=t/)(.*?)(?=\\\\?)\",\n  apple_playlistID_regex: \"\",\n};\n\n//This function sets up the clientID and secret depending on which platform is specified\nconst setupCredentials = (source) => {\n  let required_clientID = \"\";\n  let required_secret = \"\";\n\n  //Select the correct values\n  if (source === \"spotify\") {\n    required_clientID = credentials.spotify_clientID;\n    required_secret = credentials.spotify_secret;\n  } else if (source === \"apple\") {\n    required_clientID = credentials.apple_clientID;\n    required_secret = credentials.apple_secret;\n  }\n\n  return { clientID: required_clientID, secret: required_secret };\n};\n\n//Get the Spotify access token\nconst fetchSpotifyToken = (searchData) => {\n  let stringToEncode = `${searchData.clientID}:${searchData.secret}`; //Encoded client ID and secret needed to get access token\n  let token; //Variable that will hold the promise returned by the fetch function\n\n  //Headers and body set up according to how Spotify requires it (https://developer.spotify.com/documentation/general/guides/authorization/client-credentials/)\n  let tokenResponse = fetch(\"https://accounts.spotify.com/api/token\", {\n    method: \"POST\",\n    headers: {\n      \"Content-type\": \"application/x-www-form-urlencoded\",\n      Authorization: `Basic ${Buffer.from(stringToEncode).toString(\"base64\")}`,\n    },\n    body: \"grant_type=client_credentials\",\n  })\n    .then((tokenResponse) => {\n      if (tokenResponse.ok) console.log(\"Successful\");\n      else console.log(\"Not successful\");\n      return tokenResponse.json();\n    })\n    .catch((error) => {\n      console.log(error);\n    });\n\n  return tokenResponse; //Return the promise that the fetch function returns\n};\n\n//Get the Apple Music access token\nconst fetchAppleToken = (searchData) => {};\n\n//Function to get the required credentials (client ID, secret, and access token)\n//Made it an async function so that we can wait for the fetching of the access token to finish before returning it\nexport const setupToken = async (source) => {\n  let searchData = setupCredentials(source); //Object containing the required clientID and secret\n  let tokenPromise; //Variable that will hold the promise returned from the fetch API\n  let token = \"\"; //Variable used to hold access token from source platform\n\n  //Get the access token from the right api based on the source\n  if (source === \"spotify\") {\n    tokenPromise = await fetchSpotifyToken(searchData); //await will make the code wait for the fetch function to resolve/reject the promise, but for it to work it needs to return a promise\n  } else if (source === \"apple\") {\n    tokenPromise = await fetchAppleToken(searchData);\n  }\n\n  token = tokenPromise.access_token;\n  return { ...searchData, token };\n};\n\n//Extract the unique playlist ID from the url using the right regex pattern\nconst extractPlaylistID = (link, source) => {\n  let playlistID = \"\";\n\n  //Extract the playlist ID from the share link\n  if (source === \"spotify\") {\n    const regex = new RegExp(regexes.spotify_playlistID_regex); //Select the spotify playlist ID regex\n    playlistID = link.match(regex)[0];\n  }\n  // else if (source === \"apple\") {\n  //   const regex = new RegExp(regexes.apple_playlistID_regex);\n  //   plalylistID = link.match(regex);\n  //   console.log(playlistID);\n  // }\n\n  return playlistID;\n};\n\nexport const fetchPlaylist = (link, token, source) => {\n  const playlistID = extractPlaylistID(link, source);\n\n  return fetch(`https://api.spotify.com/v1/playlists/${playlistID}`, {\n    method: \"GET\",\n    headers: {\n      \"Content-type\": \"application/json\",\n      Authorization: \"Bearer \" + token,\n    },\n  })\n    .then((playlistResponse) => {\n      if (playlistResponse.ok) {\n        console.log(\"Retrieved playlist successfully\");\n      } else console.log(\"Error with retrieving playlist\");\n      return playlistResponse.json();\n    })\n    .catch((error) => console.log(error));\n};\n",[],{"ruleId":"44","severity":1,"message":"45","line":8,"column":10,"nodeType":"46","messageId":"47","endLine":8,"endColumn":16},{"ruleId":"44","severity":1,"message":"48","line":26,"column":10,"nodeType":"46","messageId":"47","endLine":26,"endColumn":14},{"ruleId":"44","severity":1,"message":"49","line":34,"column":10,"nodeType":"46","messageId":"47","endLine":34,"endColumn":21},{"ruleId":"44","severity":1,"message":"50","line":37,"column":9,"nodeType":"46","messageId":"47","endLine":37,"endColumn":21},{"ruleId":"44","severity":1,"message":"51","line":84,"column":9,"nodeType":"46","messageId":"47","endLine":84,"endColumn":15},{"ruleId":"52","severity":1,"message":"53","line":108,"column":15,"nodeType":"54","endLine":111,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":112,"column":15,"nodeType":"54","endLine":115,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":116,"column":15,"nodeType":"54","endLine":119,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":131,"column":15,"nodeType":"54","endLine":134,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":135,"column":15,"nodeType":"54","endLine":138,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":139,"column":15,"nodeType":"54","endLine":142,"endColumn":17},{"ruleId":"52","severity":1,"message":"53","line":213,"column":19,"nodeType":"54","endLine":213,"endColumn":54},{"ruleId":"44","severity":1,"message":"55","line":38,"column":7,"nodeType":"46","messageId":"47","endLine":38,"endColumn":12},"no-unused-vars","'Buffer' is defined but never used.","Identifier","unusedVar","'dest' is assigned a value but never used.","'sourceToken' is assigned a value but never used.","'playlistLink' is assigned a value but never used.","'errors' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'token' is defined but never used."]